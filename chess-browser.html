<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <title>Satranç</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #222;
      color: #f5f5f5;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
      margin: 0;
      padding: 0;
      overflow-y: hidden; /* Dikey scroll yok */
    }

    .container {
      background: #333;
      padding: 16px;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,.5);
      max-width: 600px;
      position: relative;
      z-index: 1;
      display: flex;
      flex-direction: column;
      align-items: center; /* İçerikleri ortala */
    }

    h1,
    #status,
    #clocks,
    #controls {
      width: 100%;
      text-align: center;
    }

    h1 {
      margin: 0 0 8px;
      font-size: 20px;
    }

    #status {
      margin: 4px 0 6px;
      font-size: 14px;
      min-height: 18px;
    }

    /* Saatler */
    #clocks {
      display: flex;
      justify-content: space-between;
      gap: 8px;
      font-size: 14px;
      margin-bottom: 8px;
    }

    #clocks div {
      flex: 1;
      text-align: center;
      padding: 4px 6px;
      border-radius: 6px;
      background: #2a2a2a;
    }

    #whiteClockLabel {
      border: 1px solid #ddd;
    }

    #blackClockLabel {
      border: 1px solid #444;
    }

    /* Ortadaki popup’lar için arka plan + kutu */
    .overlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.6);
      z-index: 999;
    }

    .modal {
      background: #2c2c2c;
      border-radius: 12px;
      padding: 16px 20px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.8);
      text-align: center;
      min-width: 260px;
    }

    #sideSelectTitle,
    #promoLabel {
      margin-bottom: 8px;
      font-size: 14px;
    }

    #sideIcons {
      display: flex;
      justify-content: center;
      gap: 16px;
      margin-bottom: 10px;
    }

    #sideIcons button,
    #promoChoices button {
      border-radius: 50%;
      border: 2px solid transparent;
      cursor: pointer;
      width: 56px;
      height: 56px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 32px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.7);
    }

    .sideWhite {
      background: #f0d9b5;
      border-color: #000;
      color: #fff;
      text-shadow:
        0 0 1px #000,
        0 0 2px #000;
    }

    .sideBlack {
      background: #4b2e19;
      border-color: #f5f5f5;
      color: #000;
      text-shadow:
        0 0 1px #fff,
        0 0 2px #fff;
    }

    #sideIcons button:hover,
    #promoChoices button:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 14px rgba(0,0,0,0.9);
    }

    /* Süre ayarları */
    #timeSettings {
      margin-top: 6px;
      padding-top: 8px;
      border-top: 1px solid #444;
      font-size: 13px;
      text-align: left;
    }

    #timeSettingsRow {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 4px;
      align-items: center;
      justify-content: center;
    }

    #timeSettingsRow label {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    #timeSettingsRow input[type="number"] {
      width: 60px;
      padding: 2px 4px;
      border-radius: 4px;
      border: 1px solid #555;
      background: #1f1f1f;
      color: #f5f5f5;
    }

    #boardContainer {
      margin: 0 auto 6px;
      display: flex;
      flex-direction: column;
      align-items: center; /* Tahta + koordinatlar ortalı */
    }

    .filesRow {
      display: flex;
      justify-content: space-between;
      width: 480px;
      font-size: 12px;
      padding: 0 4px;
      box-sizing: border-box;
      opacity: 0.85;
    }

    .filesRow span {
      width: 60px;
      text-align: center;
    }

    .ranksWrapper {
      display: flex;
      align-items: stretch;
    }

    .ranksCol {
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      font-size: 12px;
      padding: 4px 2px;
      box-sizing: border-box;
      opacity: 0.85;
    }

    .ranksCol span {
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 14px;
    }

    #board {
      display: grid;
      grid-template-columns: repeat(8, 60px);
      grid-template-rows: repeat(8, 60px);
      border: 3px solid #111;
      border-radius: 8px;
      overflow: hidden;
    }

    .square {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 36px;
      cursor: pointer;
      user-select: none;
      box-sizing: border-box;
      touch-action: none;
}


    .light-square {
      background: #f0d9b5;
      color: #000;
    }

    .dark-square {
      background: #b58863;
      color: #000;
    }

    .square.selected {
      outline: 3px solid #00bfff;
      outline-offset: -3px;
    }

    .square.highlight-move {
      box-shadow: inset 0 0 0 4px rgba(0, 0, 0, 0.3);
    }

    .square.highlight-capture {
      box-shadow: inset 0 0 0 4px rgba(200, 0, 0, 0.8);
    }

    /* Rakibin SON hamlesi için işaretleyiciler */
    .square.last-opponent-from {
      box-shadow: inset 0 0 0 4px rgba(255, 215, 0, 0.95);
    }

    .square.last-opponent-to {
      box-shadow: inset 0 0 0 4px rgba(50, 205, 50, 0.95);
    }

    .square.white-piece {
      color: #fff;
      text-shadow:
        0 0 1px #000,
        0 0 2px #000,
        0 0 3px #000;
    }

    .square.black-piece {
      color: #000;
      text-shadow: 0 0 1px #fff;
    }

    #controls {
      text-align: center;
      margin-top: 4px;
    }

    #restartBtn {
      padding: 8px 16px;
      font-size: 14px;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      background: #4caf50;
      color: #fff;
      font-weight: 600;
      display: none;
    }

    #restartBtn:hover {
      opacity: 0.9;
    }
  
/* Drag ghost */
.drag-ghost{
  position:fixed;
  pointer-events:none;
  font-size:42px;
  opacity:0.6;
  transform:translate(-50%,-50%);
  z-index:9999;
}
.drag-ghost.white{ color:#ffffff; text-shadow:0 0 4px #000; }
.drag-ghost.black{ color:#000000; text-shadow:0 0 4px #fff; }


    /* Terfi seçimleri yatay hizalansın */
    #promoChoices {
      display: flex;
      justify-content: center;
      gap: 14px;
      flex-wrap: nowrap;
    }

    /* Oyun sonu penceresi */
    #gameOverModalMessage{
      margin-bottom: 10px;
      font-size: 14px;
      line-height: 1.3;
    }

    #gameOverRestartBtn{
      padding: 10px 16px;
      font-size: 14px;
      border-radius: 8px;
      border: none;
      cursor: pointer;
      background: #4caf50;
      color: #fff;
      font-weight: 700;
      width: 100%;
    }
    #gameOverRestartBtn:hover{ opacity: 0.92; }

</style>
</head>
<body>
<div class="container">
  <h1>Rakibiniz: Rastgele Hamle Yapan Bilgisayar</h1>
  <div id="status">Önce taş renginizi ve süreyi seçin.</div>

  <div id="clocks">
    <div id="whiteClockLabel">Beyaz: <span id="whiteClock">05:00</span></div>
    <div id="blackClockLabel">Siyah: <span id="blackClock">05:00</span></div>
  </div>

  <div id="boardContainer">
    <div id="filesTop" class="filesRow"></div>
    <div class="ranksWrapper">
      <div id="ranksLeft" class="ranksCol"></div>
      <div id="board"></div>
      <div id="ranksRight" class="ranksCol"></div>
    </div>
    <div id="filesBottom" class="filesRow"></div>
  </div>

  <div id="controls">
    <button id="restartBtn">Yeniden Oyna</button>
  </div>
</div>

<!-- Taş rengini + süreyi seçme popup -->
<div id="sideOverlay" class="overlay">
  <div id="sideSelect" class="modal">
    <div id="sideSelectTitle">Taş renginizi seçin:</div>
    <div id="sideIcons">
      <!-- Solda siyah, sağda beyaz; renkler tahtayla uyumlu, belirgin -->
      <button id="playBlack" class="sideBlack" title="Siyahla oyna">♚</button>
      <button id="playWhite" class="sideWhite" title="Beyazla oyna">♔</button>
    </div>

    <div id="timeSettings">
      <div><strong>Süre:</strong> Dakika + hamlebaşı eklenen Saniye</div>
      <div id="timeSettingsRow">
        <label>
          Dakika:
          <input type="number" id="timeMinutes" min="1" max="180" value="5">
        </label>
        <label>
          Ek saniye:
          <input type="number" id="timeIncrement" min="0" max="60" value="3">
        </label>
      </div>
    </div>
  </div>
</div>

<!-- Terfi popup -->
<div id="promoOverlay" class="overlay" style="display:none;">
  <div id="promo" class="modal">
    <div id="promoLabel">Terfi taşını seç:</div>
    <div id="promoChoices"></div>
  </div>
</div>


<!-- Oyun sonu popup -->
<div id="gameOverOverlay" class="overlay" style="display:none;">
  <div class="modal">
    <div id="gameOverModalMessage"></div>
    <button id="gameOverRestartBtn">Yeniden Başla</button>
  </div>
</div>


<script>
  let board;
  let whiteToMove;
  let gameOver;
  let selectedSquare = null;
  let legalMovesForSelected = [];

  // Pointer tabanlı sürükleme durumu (mobil uyumlu)
  const DRAG_THRESHOLD_PX = 8;
  let pointerDownInfo = null; // {row,col,startX,startY}

// Drag ghost state
let dragGhost = null;
let ghostPiece = null;

function createGhost(piece, x, y){
  removeGhost();
  ghostPiece = piece;
  dragGhost = document.createElement('div');
  dragGhost.className = 'drag-ghost ' + (isWhitePiece(piece) ? 'white' : 'black');
  dragGhost.textContent = pieceSymbols[piece] || '';
  document.body.appendChild(dragGhost);
  moveGhost(x, y);
}

function moveGhost(x, y){
  if (!dragGhost) return;
  dragGhost.style.left = x + 'px';
  dragGhost.style.top = y + 'px';
}

function removeGhost(){
  if (dragGhost){
    dragGhost.remove();
    dragGhost = null;
    ghostPiece = null;
  }
}

  let isDragging = false;

  let castlingRights;
  let enPassantTarget;
  let halfmoveClock;
  let fullmoveNumber;
  let positionCounts;

  let humanIsWhite = true;
  let sideChosen = false;
  let renderFlipped = false;

  let awaitingPromotion = false;
  let pendingPromotionMoves = [];

  /* Rakibin son hamlesi için */
  let lastOpponentMove = null;

  /* Saatler */
  let baseMinutes = 5;
  let incrementSeconds = 3;
  let whiteTimeMs = baseMinutes * 60 * 1000;
  let blackTimeMs = baseMinutes * 60 * 1000;
  let clockInterval = null;
  let lastTickTimestamp = null;

  const boardElement = document.getElementById('board');
  const statusElement = document.getElementById('status');
  const restartBtn = document.getElementById('restartBtn');

  const sideOverlay = document.getElementById('sideOverlay');
  const playWhiteBtn = document.getElementById('playWhite');
  const playBlackBtn = document.getElementById('playBlack');

  const promoOverlay = document.getElementById('promoOverlay');
  const promoChoices = document.getElementById('promoChoices');

  const gameOverOverlay = document.getElementById('gameOverOverlay');
  const gameOverModalMessage = document.getElementById('gameOverModalMessage');
  const gameOverRestartBtn = document.getElementById('gameOverRestartBtn');

  const filesTopEl = document.getElementById('filesTop');
  const filesBottomEl = document.getElementById('filesBottom');
  const ranksLeftEl = document.getElementById('ranksLeft');
  const ranksRightEl = document.getElementById('ranksRight');

  const whiteClockEl = document.getElementById('whiteClock');
  const blackClockEl = document.getElementById('blackClock');
  const timeMinutesInput = document.getElementById('timeMinutes');
  const timeIncrementInput = document.getElementById('timeIncrement');

  const pieceSymbols = {
    'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙',
    'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟︎'
  };

  function isWhitePiece(piece) { return piece && piece === piece.toUpperCase(); }
  function isBlackPiece(piece) { return piece && piece === piece.toLowerCase(); }
  function inBounds(r, c) { return r >= 0 && r < 8 && c >= 0 && c < 8; }
  function cloneBoard(b) { return b.map(row => row.slice()); }

  function makeMoveOnBoard(b, move) {
    const newBoard = cloneBoard(b);
    const piece = newBoard[move.fromRow][move.fromCol];
    newBoard[move.fromRow][move.fromCol] = '';

    if (move.isEnPassant) {
      const capRow = move.fromRow;
      const capCol = move.toCol;
      newBoard[capRow][capCol] = '';
    }

    let newPiece = piece;
    if (move.promotion) newPiece = move.promotion;
    newBoard[move.toRow][move.toCol] = newPiece;

    if (move.isCastling) {
      if (piece === 'K' && move.toCol === 6) {
        newBoard[7][5] = 'R';
        newBoard[7][7] = '';
      } else if (piece === 'K' && move.toCol === 2) {
        newBoard[7][3] = 'R';
        newBoard[7][0] = '';
      } else if (piece === 'k' && move.toCol === 6) {
        newBoard[0][5] = 'r';
        newBoard[0][7] = '';
      } else if (piece === 'k' && move.toCol === 2) {
        newBoard[0][3] = 'r';
        newBoard[0][0] = '';
      }
    }

    return newBoard;
  }

  function findKingPosition(b, isWhite) {
    const target = isWhite ? 'K' : 'k';
    for (let r = 0; r < 8; r++)
      for (let c = 0; c < 8; c++)
        if (b[r][c] === target) return { row: r, col: c };
    return null;
  }

  function pieceAttacksSquare(b, fromRow, fromCol, toRow, toCol) {
    const piece = b[fromRow][fromCol];
    if (!piece) return false;
    const isWhite = isWhitePiece(piece);
    const p = piece.toLowerCase();
    const dr = toRow - fromRow;
    const dc = toCol - fromCol;
    const absDr = Math.abs(dr);
    const absDc = Math.abs(dc);

    if (p === 'p') {
      if (isWhite) return dr === -1 && Math.abs(dc) === 1;
      return dr === 1 && Math.abs(dc) === 1;
    }

    if (p === 'n') {
      return (absDr === 2 && absDc === 1) || (absDr === 1 && absDc === 2);
    }

    if (p === 'b') {
      if (absDr !== absDc || absDr === 0) return false;
      const stepR = dr > 0 ? 1 : -1;
      const stepC = dc > 0 ? 1 : -1;
      for (let i = 1; i < absDr; i++) {
        if (b[fromRow + i * stepR][fromCol + i * stepC] !== '') return false;
      }
      return true;
    }

    if (p === 'r') {
      if (!(fromRow === toRow || fromCol === toCol)) return false;
      if (fromRow === toRow) {
        const stepC = dc > 0 ? 1 : -1;
        for (let c = fromCol + stepC; c !== toCol; c += stepC)
          if (b[fromRow][c] !== '') return false;
      } else {
        const stepR = dr > 0 ? 1 : -1;
        for (let r = fromRow + stepR; r !== toRow; r += stepR)
          if (b[r][fromCol] !== '') return false;
      }
      return true;
    }

    if (p === 'q') {
      if (absDr === absDc && absDr !== 0) {
        const stepR = dr > 0 ? 1 : -1;
        const stepC = dc > 0 ? 1 : -1;
        for (let i = 1; i < absDr; i++) {
          if (b[fromRow + i * stepR][fromCol + i * stepC] !== '') return false;
        }
        return true;
      } else if (fromRow === toRow || fromCol === toCol) {
        if (fromRow === toRow) {
          const stepC = dc > 0 ? 1 : -1;
          for (let c = fromCol + stepC; c !== toCol; c += stepC)
            if (b[fromRow][c] !== '') return false;
        } else {
          const stepR = dr > 0 ? 1 : -1;
          for (let r = fromRow + stepR; r !== toRow; r += stepR)
            if (b[r][fromCol] !== '') return false;
        }
        return true;
      }
      return false;
    }

    if (p === 'k') {
      return absDr <= 1 && absDc <= 1 && (absDr + absDc > 0);
    }

    return false;
  }

  function isSquareAttacked(b, row, col, byWhite) {
    for (let r = 0; r < 8; r++)
      for (let c = 0; c < 8; c++) {
        const piece = b[r][c];
        if (!piece) continue;
        if (byWhite && !isWhitePiece(piece)) continue;
        if (!byWhite && !isBlackPiece(piece)) continue;
        if (pieceAttacksSquare(b, r, c, row, col)) return true;
      }
    return false;
  }

  function isInCheck(b, isWhite) {
    const kingPos = findKingPosition(b, isWhite);
    if (!kingPos) return false;
    return isSquareAttacked(b, kingPos.row, kingPos.col, !isWhite);
  }

  function generatePseudoMovesForPiece(b, row, col, isWhiteTurn) {
    const moves = [];
    const piece = b[row][col];
    if (!piece) return moves;
    const isWhite = isWhitePiece(piece);
    if (isWhite !== isWhiteTurn) return moves;
    const p = piece.toLowerCase();

    const pushMove = (toRow, toCol, options = {}) => {
      if (!inBounds(toRow, toCol)) return;
      const target = b[toRow][toCol];
      if (!options.isEnPassant) {
        if (target && ((isWhite && isWhitePiece(target)) || (!isWhite && isBlackPiece(target)))) return;
      }
      moves.push({
        fromRow: row,
        fromCol: col,
        toRow,
        toCol,
        promotion: options.promotion || null,
        isEnPassant: !!options.isEnPassant,
        isCastling: !!options.isCastling
      });
    };

    if (p === 'p') {
      const dir = isWhite ? -1 : 1;
      const startRow = isWhite ? 6 : 1;
      const lastRank = isWhite ? 0 : 7;

      const oneStepRow = row + dir;
      if (inBounds(oneStepRow, col) && b[oneStepRow][col] === '') {
        if (oneStepRow === lastRank) {
          const promos = isWhite ? ['Q','R','B','N'] : ['q','r','b','n'];
          promos.forEach(pp => pushMove(oneStepRow, col, { promotion: pp }));
        } else {
          pushMove(oneStepRow, col);
        }

        const twoStepRow = row + 2 * dir;
        if (row === startRow && inBounds(twoStepRow, col) && b[twoStepRow][col] === '') {
          pushMove(twoStepRow, col);
        }
      }

      for (let dc of [-1, 1]) {
        const tr = row + dir;
        const tc = col + dc;
        if (!inBounds(tr, tc)) continue;
        const target = b[tr][tc];
        if (target && ((isWhite && isBlackPiece(target)) || (!isWhite && isWhitePiece(target)))) {
          if (tr === lastRank) {
            const promos = isWhite ? ['Q','R','B','N'] : ['q','r','b','n'];
            promos.forEach(pp => pushMove(tr, tc, { promotion: pp }));
          } else {
            pushMove(tr, tc);
          }
        }
      }

      if (enPassantTarget) {
        for (let dc of [-1, 1]) {
          const tr = row + dir;
          const tc = col + dc;
          if (tr === enPassantTarget.row && tc === enPassantTarget.col) {
            const capRow = row;
            const capCol = tc;
            const targetPawn = b[capRow][capCol];
            if (targetPawn && ((isWhite && isBlackPiece(targetPawn)) || (!isWhite && isWhitePiece(targetPawn)))) {
              pushMove(tr, tc, { isEnPassant: true });
            }
          }
        }
      }

      return moves;
    }

    if (p === 'n') {
      const knightMoves = [
        [2, 1], [2, -1], [-2, 1], [-2, -1],
        [1, 2], [1, -2], [-1, 2], [-1, -2]
      ];
      for (let [dr, dc] of knightMoves) {
        const tr = row + dr;
        const tc = col + dc;
        if (!inBounds(tr, tc)) continue;
        const target = b[tr][tc];
        if (!target || (isWhite && isBlackPiece(target)) || (!isWhite && isWhitePiece(target))) {
          pushMove(tr, tc);
        }
      }
      return moves;
    }

    if (p === 'b' || p === 'q') {
      const directions = [
        [1, 1], [1, -1], [-1, 1], [-1, -1]
      ];
      for (let [dr, dc] of directions) {
        let tr = row + dr;
        let tc = col + dc;
        while (inBounds(tr, tc)) {
          const target = b[tr][tc];
          if (!target) {
            pushMove(tr, tc);
          } else {
            if ((isWhite && isBlackPiece(target)) || (!isWhite && isWhitePiece(target))) {
              pushMove(tr, tc);
            }
            break;
          }
          tr += dr;
          tc += dc;
        }
      }
    }

    if (p === 'r' || p === 'q') {
      const directions = [
        [1, 0], [-1, 0], [0, 1], [0, -1]
      ];
      for (let [dr, dc] of directions) {
        let tr = row + dr;
        let tc = col + dc;
        while (inBounds(tr, tc)) {
          const target = b[tr][tc];
          if (!target) {
            pushMove(tr, tc);
          } else {
            if ((isWhite && isBlackPiece(target)) || (!isWhite && isWhitePiece(target))) {
              pushMove(tr, tc);
            }
            break;
          }
          tr += dr;
          tc += dc;
        }
      }
    }

    if (p === 'k') {
      for (let dr = -1; dr <= 1; dr++)
        for (let dc = -1; dc <= 1; dc++) {
          if (dr === 0 && dc === 0) continue;
          const tr = row + dr;
          const tc = col + dc;
          if (!inBounds(tr, tc)) continue;
          const target = b[tr][tc];
          if (!target || (isWhite && isBlackPiece(target)) || (!isWhite && isWhitePiece(target))) {
            pushMove(tr, tc);
          }
        }

      const isWhiteSide = isWhite;
      const rank = isWhiteSide ? 7 : 0;
      const kingFile = 4;
      if (row === rank && col === kingFile && !isInCheck(b, isWhiteSide)) {
        const rights = castlingRights;
        const byWhite = !isWhiteSide;

        if ((isWhiteSide && rights.whiteK) || (!isWhiteSide && rights.blackK)) {
          if (b[rank][5] === '' && b[rank][6] === '' &&
              b[rank][7] === (isWhiteSide ? 'R' : 'r') &&
              !isSquareAttacked(b, rank, 5, byWhite) &&
              !isSquareAttacked(b, rank, 6, byWhite)) {
            pushMove(rank, 6, { isCastling: true });
          }
        }

        if ((isWhiteSide && rights.whiteQ) || (!isWhiteSide && rights.blackQ)) {
          if (b[rank][1] === '' && b[rank][2] === '' && b[rank][3] === '' &&
              b[rank][0] === (isWhiteSide ? 'R' : 'r') &&
              !isSquareAttacked(b, rank, 3, byWhite) &&
              !isSquareAttacked(b, rank, 2, byWhite)) {
            pushMove(rank, 2, { isCastling: true });
          }
        }
      }
    }

    return moves;
  }

  function generateLegalMoves(isWhiteTurn) {
    const result = [];
    for (let r = 0; r < 8; r++)
      for (let c = 0; c < 8; c++) {
        const piece = board[r][c];
        if (!piece) continue;
        if (isWhiteTurn && !isWhitePiece(piece)) continue;
        if (!isWhiteTurn && !isBlackPiece(piece)) continue;
        const pseudoMoves = generatePseudoMovesForPiece(board, r, c, isWhiteTurn);
        for (let m of pseudoMoves) {
          const newBoard = makeMoveOnBoard(board, m);
          if (!isInCheck(newBoard, isWhiteTurn)) result.push(m);
        }
      }
    return result;
  }

  function getCastlingRightsString() {
    let s = '';
    if (castlingRights.whiteK) s += 'K';
    if (castlingRights.whiteQ) s += 'Q';
    if (castlingRights.blackK) s += 'k';
    if (castlingRights.blackQ) s += 'q';
    return s || '-';
  }

  function getEnPassantString() {
    if (!enPassantTarget) return '-';
    const files = 'abcdefgh';
    const ranks = '87654321';
    const file = files[enPassantTarget.col];
    const rank = ranks[enPassantTarget.row];
    return file + rank;
  }

  function getPositionKey() {
    const rows = board.map(row => row.map(p => p || '.').join('')).join('/');
    const side = whiteToMove ? 'w' : 'b';
    const castles = getCastlingRightsString();
    const ep = getEnPassantString();
    return rows + ' ' + side + ' ' + castles + ' ' + ep;
  }

  function recordPosition() {
    const key = getPositionKey();
    positionCounts[key] = (positionCounts[key] || 0) + 1;
  }

  function isThreefoldRepetition() {
    const key = getPositionKey();
    return (positionCounts[key] || 0) >= 3;
  }

  function hasSufficientMaterial(b) {
    let whiteBishops = [];
    let blackBishops = [];
    let whiteKnights = 0;
    let blackKnights = 0;

    for (let r = 0; r < 8; r++)
      for (let c = 0; c < 8; c++) {
        const piece = b[r][c];
        if (!piece) continue;
        const p = piece.toLowerCase();
        if (p === 'k') continue;

        if (p === 'p' || p === 'q' || p === 'r') {
          return true;
        }

        const isWhite = isWhitePiece(piece);
        if (p === 'b') {
          const isLightSquare = (r + c) % 2 === 0;
          if (isWhite) whiteBishops.push(isLightSquare);
          else blackBishops.push(isLightSquare);
        } else if (p === 'n') {
          if (isWhite) whiteKnights++;
          else blackKnights++;
        }
      }

    const totalMinors = whiteBishops.length + blackBishops.length + whiteKnights + blackKnights;

    if (totalMinors === 0) return false;
    if (totalMinors === 1) return false;

    if (totalMinors === 2 &&
        whiteKnights === 0 && blackKnights === 0 &&
        whiteBishops.length + blackBishops.length === 2) {
      const allBishops = whiteBishops.concat(blackBishops);
      const allSameColor = allBishops.every(v => v === allBishops[0]);
      if (allSameColor) return false;
    }

    return true;
  }

  /* Kimin MAT için yeterli taşları var? (süre kuralı için) */
  function sideHasMatingMaterial(b, isWhiteSide) {
    let hasPawnOrBig = false;
    let bishops = 0;
    let knights = 0;

    for (let r = 0; r < 8; r++)
      for (let c = 0; c < 8; c++) {
        const piece = b[r][c];
        if (!piece) continue;
        const isWhite = isWhitePiece(piece);
        if (isWhite !== isWhiteSide) continue;

        const p = piece.toLowerCase();
        if (p === 'p' || p === 'q' || p === 'r') {
          hasPawnOrBig = true;
        } else if (p === 'b') {
          bishops++;
        } else if (p === 'n') {
          knights++;
        }
      }

    if (hasPawnOrBig) return true;
    if (bishops + knights >= 2) return true; // örn: çift fil, at+fil vb.
    return false; // tek at / tek fil => yetersiz
  }

  function evaluateGameStateAfterMove() {
    if (halfmoveClock >= 100) {
      return { gameOver: true, message: "Berabere: 50 hamle kuralı." };
    }

    if (!hasSufficientMaterial(board)) {
      return { gameOver: true, message: "Berabere: yetersiz materyal." };
    }

    if (isThreefoldRepetition()) {
      return { gameOver: true, message: "Berabere: aynı pozisyon 3 kez tekrarlandı." };
    }

    const sideToMoveIsWhite = whiteToMove;
    const legal = generateLegalMoves(sideToMoveIsWhite);
    if (legal.length === 0) {
      if (isInCheck(board, sideToMoveIsWhite)) {
        if (sideToMoveIsWhite) {
          return { gameOver: true, message: "Mat! Siyah kazandı." };
        } else {
          return { gameOver: true, message: "Mat! Beyaz kazandı." };
        }
      } else {
        return { gameOver: true, message: "Berabere: pat." };
      }
    }

    return { gameOver: false, message: null };
  }

  function applyMove(move) {
    const fromRow = move.fromRow;
    const fromCol = move.fromCol;
    const toRow = move.toRow;
    const toCol = move.toCol;

    const piece = board[fromRow][fromCol];
    const targetBefore = board[toRow][toCol];

    let capturedPiece = targetBefore;
    if (move.isEnPassant) {
      const capRow = fromRow;
      const capCol = toCol;
      capturedPiece = board[capRow][capCol];
    }

    if (piece.toLowerCase() === 'p' || capturedPiece) {
      halfmoveClock = 0;
    } else {
      halfmoveClock++;
    }

    enPassantTarget = null;

    if (move.isEnPassant) {
      board[fromRow][fromCol] = '';
      const capRow = fromRow;
      const capCol = toCol;
      board[capRow][capCol] = '';
      const newPiece = move.promotion ? move.promotion : piece;
      board[toRow][toCol] = newPiece;
    } else if (move.isCastling) {
      board[fromRow][fromCol] = '';
      board[toRow][toCol] = piece;
      if (piece === 'K') {
        if (toCol === 6) {
          board[7][7] = '';
          board[7][5] = 'R';
        } else if (toCol === 2) {
          board[7][0] = '';
          board[7][3] = 'R';
        }
      } else if (piece === 'k') {
        if (toCol === 6) {
          board[0][7] = '';
          board[0][5] = 'r';
        } else if (toCol === 2) {
          board[0][0] = '';
          board[0][3] = 'r';
        }
      }
    } else {
      board[fromRow][fromCol] = '';
      const newPiece = move.promotion ? move.promotion : piece;
      board[toRow][toCol] = newPiece;

      if (piece.toLowerCase() === 'p' && Math.abs(toRow - fromRow) === 2) {
        const midRow = (toRow + fromRow) / 2;
        enPassantTarget = { row: midRow, col: fromCol };
      }
    }

    if (piece === 'K') {
      castlingRights.whiteK = false;
      castlingRights.whiteQ = false;
    } else if (piece === 'k') {
      castlingRights.blackK = false;
      castlingRights.blackQ = false;
    }

    if (piece === 'R') {
      if (fromRow === 7 && fromCol === 0) castlingRights.whiteQ = false;
      if (fromRow === 7 && fromCol === 7) castlingRights.whiteK = false;
    } else if (piece === 'r') {
      if (fromRow === 0 && fromCol === 0) castlingRights.blackQ = false;
      if (fromRow === 0 && fromCol === 7) castlingRights.blackK = false;
    }

    if (capturedPiece === 'R') {
      if (toRow === 7 && toCol === 0) castlingRights.whiteQ = false;
      if (toRow === 7 && toCol === 7) castlingRights.whiteK = false;
    } else if (capturedPiece === 'r') {
      if (toRow === 0 && toCol === 0) castlingRights.blackQ = false;
      if (toRow === 0 && toCol === 7) castlingRights.blackK = false;
    }

    whiteToMove = !whiteToMove;
    if (whiteToMove) fullmoveNumber++;

    recordPosition();
  }

  function renderCoords() {
    const files = ['a','b','c','d','e','f','g','h'];
    filesTopEl.innerHTML = '';
    filesBottomEl.innerHTML = '';
    ranksLeftEl.innerHTML = '';
    ranksRightEl.innerHTML = '';

    files.forEach(ch => {
      const sp = document.createElement('span');
      sp.textContent = ch;
      filesTopEl.appendChild(sp);
    });
    [...files].reverse().forEach(ch => {
      const sp = document.createElement('span');
      sp.textContent = ch;
      filesBottomEl.appendChild(sp);
    });

    for (let r = 8; r >= 1; r--) {
      const sp = document.createElement('span');
      sp.textContent = r;
      ranksLeftEl.appendChild(sp);
    }
    for (let r = 1; r <= 8; r++) {
      const sp = document.createElement('span');
      sp.textContent = r;
      ranksRightEl.appendChild(sp);
    }
  }

  function renderBoard() {
    boardElement.innerHTML = '';
    for (let vr = 0; vr < 8; vr++) {
      for (let vc = 0; vc < 8; vc++) {
        const r = renderFlipped ? 7 - vr : vr;
        const c = renderFlipped ? 7 - vc : vc;

        const square = document.createElement('div');
        square.classList.add('square');
        const isLight = (r + c) % 2 === 0;
        square.classList.add(isLight ? 'light-square' : 'dark-square');
        square.dataset.row = r;
        square.dataset.col = c;

        const piece = board[r][c];
        if (piece) {
          square.textContent = pieceSymbols[piece] || '';
          if (isWhitePiece(piece)) {
            square.classList.add('white-piece');
          } else {
            square.classList.add('black-piece');
          }
        }

        if (selectedSquare && selectedSquare.row === r && selectedSquare.col === c) {
          square.classList.add('selected');
        }

        const highlight = legalMovesForSelected.find(m => m.toRow === r && m.toCol === c);
        if (highlight) {
          const target = board[r][c];
          if (target && ((whiteToMove && isBlackPiece(target)) || (!whiteToMove && isWhitePiece(target)))) {
            square.classList.add('highlight-capture');
          } else {
            square.classList.add('highlight-move');
          }
        }

        /* Rakibin son hamlesi */
        if (lastOpponentMove) {
          if (lastOpponentMove.fromRow === r && lastOpponentMove.fromCol === c) {
            square.classList.add('last-opponent-from');
          }
          if (lastOpponentMove.toRow === r && lastOpponentMove.toCol === c) {
            square.classList.add('last-opponent-to');
          }
        }

        square.addEventListener('click', onSquareClick);
        square.addEventListener('pointerdown', onSquarePointerDown);
        square.addEventListener('pointermove', onSquarePointerMove);
        square.addEventListener('pointerup', onSquarePointerUp);
        square.addEventListener('pointercancel', onSquarePointerCancel);
        boardElement.appendChild(square);
      }
    }
  }

  function showPromotionChoices(moves) {
    awaitingPromotion = true;
    pendingPromotionMoves = moves;
    promoChoices.innerHTML = '';

    const unique = [];
    moves.forEach(m => {
      const up = m.promotion.toUpperCase();
      if (!unique.includes(up)) unique.push(up);
    });

    unique.forEach(ch => {
      const btn = document.createElement('button');
      const pieceChar = humanIsWhite ? ch : ch.toLowerCase();
      btn.textContent = pieceSymbols[pieceChar];
      btn.dataset.piece = ch;
      btn.onclick = () => {
        const chosen = btn.dataset.piece;
        const mv = pendingPromotionMoves.find(m => m.promotion.toUpperCase() === chosen);
        awaitingPromotion = false;
        pendingPromotionMoves = [];
        promoOverlay.style.display = 'none';
    if (gameOverOverlay) gameOverOverlay.style.display = 'none';
        if (mv) playerMove(mv);
      };
      promoChoices.appendChild(btn);
    });

    promoOverlay.style.display = 'flex';
  }

  /* Sürükle-bırak (Pointer Events) + tıklama birlikte */
function canHumanInteract() {
  if (gameOver || awaitingPromotion || !sideChosen) return false;
  if (whiteToMove !== humanIsWhite) return false;
  return true;
}

function isHumanPieceAt(row, col) {
  const piece = board[row][col];
  if (!piece) return false;
  return (humanIsWhite && isWhitePiece(piece)) || (!humanIsWhite && isBlackPiece(piece));
}

function computeAndShowMovesForSquare(row, col) {
  selectedSquare = { row, col };
  const allLegal = generateLegalMoves(whiteToMove);
  legalMovesForSelected = allLegal.filter(m => m.fromRow === row && m.fromCol === col);
  renderBoard();
}

function onSquarePointerDown(e) {
  if (!canHumanInteract()) return;

  const row = parseInt(e.currentTarget.dataset.row, 10);
  const col = parseInt(e.currentTarget.dataset.col, 10);

  // Sadece kendi taşımız drag adayı olabilir
  if (!isHumanPieceAt(row, col)) return;

  pointerDownInfo = { row, col, startX: e.clientX, startY: e.clientY, pointerId: e.pointerId };
  isDragging = false;

  // pointer capture, move/up olaylarını kaçırmamak için
  try { e.currentTarget.setPointerCapture(e.pointerId); } catch (_) {}

  // Başka taşı sürüklemeye başlarsak olası kareler o taşa güncellensin:
  // (eşik aşılınca drag başlatacağız ve orada compute edeceğiz)
}

function onSquarePointerMove(e) {
  if (!pointerDownInfo) return;
  if (!canHumanInteract()) return;

  const dx = e.clientX - pointerDownInfo.startX;
  const dy = e.clientY - pointerDownInfo.startY;
  const dist = Math.hypot(dx, dy);

  if (!isDragging && dist >= DRAG_THRESHOLD_PX) {
    isDragging = true;
    // Drag başlayınca o taşın olası hamlelerini göster
    computeAndShowMovesForSquare(pointerDownInfo.row, pointerDownInfo.col);

    // Hayalet taşı başlat (beyaz/siyah rengine göre)
    const piece = board[pointerDownInfo.row][pointerDownInfo.col];
    if (piece) createGhost(piece, e.clientX, e.clientY);
  }

  // Drag sırasında hayalet taş imleci/parmağı takip eder
  if (isDragging) {
    moveGhost(e.clientX, e.clientY);
  }
}

function finalizeDragOrClick(e) {
  if (!pointerDownInfo) return;
  if (!canHumanInteract()) {
    pointerDownInfo = null;
    isDragging = false;
    return;
  }

  const fromRow = pointerDownInfo.row;
  const fromCol = pointerDownInfo.col;

  // Tap/click gibi davran: drag eşiği aşılmadıysa mevcut click mantığına bırak
  if (!isDragging) {
    pointerDownInfo = null;
    // click event'i de tetiklenmesin (çift çalışmasın)
    e.preventDefault();
    e.stopPropagation();
    // Eski davranış: taşa tıklayınca olası kareler görünsün
    // onSquareClick zaten bunu yapıyor; ancak bazı tarayıcılarda click gecikebilir.
    // Doğrudan çağırıyoruz:
    onSquareClick({ currentTarget: e.currentTarget });
    return;
  }

  
  // Drag bitti: hayalet taşı kaldır
  removeGhost();
// Drag bırakma: pointer altında hangi kare var?
  const el = document.elementFromPoint(e.clientX, e.clientY);
  const sq = el && el.closest ? el.closest('.square') : null;

  pointerDownInfo = null;
  isDragging = false;

  if (!sq || !sq.dataset) {
    // Tahta dışında bırakıldıysa seçim kalsın
    renderBoard();
    return;
  }

  const toRow = parseInt(sq.dataset.row, 10);
  const toCol = parseInt(sq.dataset.col, 10);

  // Seçili taşın hamleleri (drag sırasında compute edildi)
  const candidates = legalMovesForSelected.filter(m => m.fromRow === fromRow && m.fromCol === fromCol && m.toRow === toRow && m.toCol === toCol);

  if (candidates.length === 0) {
    // Geçersiz bırakma: seçim/olası kareler KALMALI
    renderBoard();
    return;
  }

  const promoMoves = candidates.filter(m => m.promotion);
  if (promoMoves.length > 0) {
    showPromotionChoices(promoMoves);
  } else {
    playerMove(candidates[0]);
    selectedSquare = null;
    legalMovesForSelected = [];
  }
  renderBoard();
}

function onSquarePointerUp(e) { finalizeDragOrClick(e); }
function onSquarePointerCancel(e) {
  // İptal: seçim kalsın, sadece drag durumunu sıfırla
  pointerDownInfo = null;
  isDragging = false;
  renderBoard();

  removeGhost();
}

  function onSquareClick(e) {
    if (gameOver || awaitingPromotion || !sideChosen) return;
    if (whiteToMove !== humanIsWhite) return;

    const row = parseInt(e.currentTarget.dataset.row, 10);
    const col = parseInt(e.currentTarget.dataset.col, 10);
    const clickedPiece = board[row][col];

    const isHumanPiece = clickedPiece &&
      ((humanIsWhite && isWhitePiece(clickedPiece)) || (!humanIsWhite && isBlackPiece(clickedPiece)));

    if (!selectedSquare) {
      if (isHumanPiece) {
        selectedSquare = { row, col };
        const allLegal = generateLegalMoves(whiteToMove);
        legalMovesForSelected = allLegal.filter(
          m => m.fromRow === row && m.fromCol === col
        );
      }
    } else {
      if (selectedSquare.row === row && selectedSquare.col === col) {
        selectedSquare = null;
        legalMovesForSelected = [];
      } else {
        const candidateMoves = legalMovesForSelected.filter(
          m => m.toRow === row && m.toCol === col
        );

        if (candidateMoves.length > 0) {
          const promoMoves = candidateMoves.filter(m => m.promotion);
          if (promoMoves.length > 0) {
            showPromotionChoices(promoMoves);
          } else {
            playerMove(candidateMoves[0]);
          }
        } else {
          if (isHumanPiece) {
            selectedSquare = { row, col };
            const allLegal = generateLegalMoves(whiteToMove);
            legalMovesForSelected = allLegal.filter(
              m => m.fromRow === row && m.fromCol === col
            );
          }
        }
      }
    }
    renderBoard();
  }

  /* Saat formatlama ve yönetimi */
  function formatTime(ms) {
    const totalSec = Math.max(0, Math.floor(ms / 1000));
    const m = Math.floor(totalSec / 60);
    const s = totalSec % 60;
    return String(m).padStart(2, '0') + ":" + String(s).padStart(2, '0');
  }

  function updateClocks() {
    whiteClockEl.textContent = formatTime(whiteTimeMs);
    blackClockEl.textContent = formatTime(blackTimeMs);
  }

  function stopClock() {
    if (clockInterval !== null) {
      clearInterval(clockInterval);
      clockInterval = null;
    }
    lastTickTimestamp = null;
  }

  function endGame(message) {
    gameOver = true;
    stopClock();
    statusElement.textContent = message;

    if (gameOverModalMessage) gameOverModalMessage.textContent = message;
    if (gameOverOverlay) gameOverOverlay.style.display = 'flex';

    // Alttaki buton da kalsın (geri uyumluluk)
    restartBtn.style.display = 'inline-block';
  }

  function tickClock() {
    if (gameOver || !sideChosen) return;
    const now = Date.now();
    if (lastTickTimestamp === null) {
      lastTickTimestamp = now;
      return;
    }
    const elapsed = now - lastTickTimestamp;
    lastTickTimestamp = now;

    if (whiteToMove) {
      whiteTimeMs -= elapsed;
      if (whiteTimeMs <= 0) {
        whiteTimeMs = 0;
        updateClocks();
        handleTimeOver(true); // beyazın süresi bitti
        return;
      }
    } else {
      blackTimeMs -= elapsed;
      if (blackTimeMs <= 0) {
        blackTimeMs = 0;
        updateClocks();
        handleTimeOver(false); // siyahın süresi bitti
        return;
      }
    }
    updateClocks();
  }

  function startClock() {
    stopClock();
    lastTickTimestamp = Date.now();
    clockInterval = setInterval(tickClock, 100);
  }


  function handleTimeOver(flagFellIsWhite) {
    if (gameOver) return;

    const winnerIsWhite = !flagFellIsWhite;
    const winnerHasMat = sideHasMatingMaterial(board, winnerIsWhite);

    if (winnerHasMat) {
      if (flagFellIsWhite) {
        endGame("Beyazın süresi bitti. Siyah kazandı.");
      } else {
        endGame("Siyahın süresi bitti. Beyaz kazandı.");
      }
    } else {
      endGame("Süre bitti ama rakibin mat için yeterli taşları yok. Oyun berabere.");
    }
  }

  function playerMove(move) {

    const movingIsWhite = whiteToMove;

    applyMove(move);

    /* Hareket yapan tarafa increment ekle */
    if (movingIsWhite) {
      whiteTimeMs += incrementSeconds * 1000;
    } else {
      blackTimeMs += incrementSeconds * 1000;
    }
    updateClocks();

    selectedSquare = null;
    legalMovesForSelected = [];
    renderBoard();

    const result = evaluateGameStateAfterMove();
    if (result.gameOver) {
      endGame(result.message);
      return;
    }

    const computerIsWhite = !humanIsWhite;
    statusElement.textContent = computerIsWhite ? "Beyaz düşünüyor (rastgele hamle)..." : "Siyah düşünüyor (rastgele hamle)...";
    setTimeout(computerMove, 400);
  }

  function computerMove() {
    if (gameOver || !sideChosen) return;

    const legal = generateLegalMoves(whiteToMove);
    if (legal.length === 0) {
      const result = evaluateGameStateAfterMove();
      endGame(result.message);
      return;
    }

    const randomIndex = Math.floor(Math.random() * legal.length);
    const move = legal[randomIndex];

    if (move.promotion) {
      move.promotion = whiteToMove ? 'Q' : 'q';
    }

    const movingIsWhite = whiteToMove;

    applyMove(move);

    /* Hareket yapan tarafa increment ekle */
    if (movingIsWhite) {
      whiteTimeMs += incrementSeconds * 1000;
    } else {
      blackTimeMs += incrementSeconds * 1000;
    }

    /* Rakibin son hamlesi kaydedilsin */
    lastOpponentMove = {
      fromRow: move.fromRow,
      fromCol: move.fromCol,
      toRow: move.toRow,
      toCol: move.toCol
    };

    updateClocks();
    renderBoard();

    const result = evaluateGameStateAfterMove();
    if (result.gameOver) {
      endGame(result.message);
      return;
    }

    statusElement.textContent = humanIsWhite ? "Sıra sizde (Beyaz)." : "Sıra sizde (Siyah).";
  }

  function resetGame() {
    stopClock();

    board = [
      ['r','n','b','q','k','b','n','r'],
      ['p','p','p','p','p','p','p','p'],
      ['','','','','','','',''],
      ['','','','','','','',''],
      ['','','','','','','',''],
      ['','','','','','','',''],
      ['P','P','P','P','P','P','P','P'],
      ['R','N','B','Q','K','B','N','R']
    ];
    whiteToMove = true;
    gameOver = false;
    selectedSquare = null;
    legalMovesForSelected = [];
    castlingRights = { whiteK: true, whiteQ: true, blackK: true, blackQ: true };
    enPassantTarget = null;
    halfmoveClock = 0;
    fullmoveNumber = 1;
    positionCounts = {};
    awaitingPromotion = false;
    pendingPromotionMoves = [];
    sideChosen = false;
    renderFlipped = !humanIsWhite ? true : false;

    lastOpponentMove = null;

    /* Süreleri inputtan oku, saatleri sıfırla */
    const m = parseInt(timeMinutesInput.value, 10);
    const s = parseInt(timeIncrementInput.value, 10);
    baseMinutes = (Number.isFinite(m) && m > 0) ? m : 5;
    incrementSeconds = (Number.isFinite(s) && s >= 0) ? s : 3;

    whiteTimeMs = baseMinutes * 60 * 1000;
    blackTimeMs = baseMinutes * 60 * 1000;
    updateClocks();

    sideOverlay.style.display = 'flex';
    promoOverlay.style.display = 'none';
    if (gameOverOverlay) gameOverOverlay.style.display = 'none';
    statusElement.textContent = "Önce taş renginizi ve süreyi seçin.";
    restartBtn.style.display = 'none';
    renderCoords();
    renderBoard();
    recordPosition();
  }

  /* Yeni oyuna başlarken side seçilince süreleri yeniden al */
  function initTimeFromInputs() {
    const m = parseInt(timeMinutesInput.value, 10);
    const s = parseInt(timeIncrementInput.value, 10);
    baseMinutes = (Number.isFinite(m) && m > 0) ? m : 5;
    incrementSeconds = (Number.isFinite(s) && s >= 0) ? s : 3;

    whiteTimeMs = baseMinutes * 60 * 1000;
    blackTimeMs = baseMinutes * 60 * 1000;
    updateClocks();
  }

  playWhiteBtn.addEventListener('click', () => {
    humanIsWhite = true;
    renderFlipped = false;
    sideChosen = true;
    initTimeFromInputs();
    sideOverlay.style.display = 'none';
    statusElement.textContent = "Sıra sizde (Beyaz).";
    renderBoard();
    startClock();
  });

  playBlackBtn.addEventListener('click', () => {
    humanIsWhite = false;
    renderFlipped = true;
    sideChosen = true;
    initTimeFromInputs();
    sideOverlay.style.display = 'none';
    statusElement.textContent = "Beyaz düşünüyor (rastgele hamle)...";
    renderBoard();
    startClock(); // Beyazın süresi akarken bilgisayar düşünüyor
    setTimeout(computerMove, 400);
  });

  restartBtn.addEventListener('click', resetGame);
  gameOverRestartBtn.addEventListener('click', resetGame);

  resetGame();
</script>
</body>
</html>
