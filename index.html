<!DOCTYPE html>
<html lang="tr">

<head>
  <meta charset="UTF-8" />

  <meta name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

  <title>Satranç</title>
  <style>
html,
body {
  height: 100%;
  width: 100%;
  margin: 0;
  padding: 0;
  overflow: hidden;
}

:root {
  --sq: 3.75rem;
  --pad: clamp(0.5rem, 1.6vh, 1rem);
  --ui-gap: clamp(0.375rem, 1vh, 0.625rem);
}

body {
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  background: #222;
  color: #f5f5f5;
  display: flex;
  justify-content: center;
  align-items: flex-start;
  min-height: 100vh;
  margin: 0;
  padding: 0;
  overflow-y: hidden;
}

.container {
  background: #333;
  padding: var(--pad);
  border-radius: 0.75rem;
  box-shadow: 0 0.625rem 1.875rem rgba(0, 0, 0, 0.5);
  width: 100%;
  height: 100%;
  max-width: 100vw;
  max-height: 100vh;
  position: relative;
  z-index: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  box-sizing: border-box;
  gap: var(--ui-gap);
}

h1,
#status {
  width: 100%;
  text-align: center;
}

h1 {
  margin: 0;
  font-size: 1.25rem;
  color: #dd5050;
}

#status {
  font-size: 0.875rem;
  min-height: 1.125rem;
}

#clocks {
  display: flex;
  justify-content: space-between;
  width: calc(var(--sq) * 8);
  gap: 0.5rem;
  font-size: 0.875rem;
  margin-top: 0.5rem;
}

#clocks div {
  flex: 1;
  text-align: center;
  padding: 0.25rem 0.375rem;
  border-radius: 0.375rem;
  background: #2a2a2a;
}

#whiteClockLabel {
  border: 0.0625rem solid #ddd;
}

#blackClockLabel {
  border: 0.0625rem solid #444;
}

.overlay {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0, 0, 0, 0.6);
  z-index: 999;
}

.modal {
  background: #2c2c2c;
  border-radius: 0.75rem; 
  padding: 1rem 1.25rem;
  box-shadow: 0 0.625rem 1.875rem rgba(0, 0, 0, 0.8);
  text-align: center;
  min-width: 16.25rem;
}

#sideSelectTitle,
#promoLabel {
  margin-bottom: 0.75rem;
  font-size: 0.875rem;
}

#sideIcons {
  display: flex;
  justify-content: center;
  gap: 1rem;
  margin-bottom: 1rem;
}

#sideIcons button,
#promoChoices button {
  border-radius: 50%;
  border: 0.125rem solid transparent;
  cursor: pointer;
  width: 3.5rem; 
  height: 3.5rem;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 2rem;
  box-shadow: 0 0.25rem 0.625rem rgba(0, 0, 0, 0.7);
}

.sideWhite {
  background: #f0d9b5;
  border-color: #000;
  color: #fff;
  text-shadow:
    0 0 0.0625rem #000,
    0 0 0.125rem #000;
}

.sideBlack {
  background: #4b2e19;
  border-color: #f5f5f5;
  color: #000;
  text-shadow:
    0 0 0.0625rem #fff,
    0 0 0.125rem #fff;
}

#sideIcons button:hover,
#promoChoices button:hover {
  transform: translateY(-0.0625rem);
  box-shadow: 0 0.375rem 0.875rem rgba(0, 0, 0, 0.9);
}

#timeSettings {
  margin-top: 0.75rem;
  padding-top: 0.5rem;
  border-top: 0.0625rem solid #444;
  font-size: 0.8125rem;
  text-align: left;
}

#timeSettingsRow {
  display: flex;
  flex-wrap: wrap;
  gap: 1.5rem;
  margin-top: 0.5rem;
  align-items: center;
  justify-content: center;
}

#timeSettingsRow label {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

#timeSettingsRow input {
  width: 3.75rem;
  padding: 0.125rem 0.25rem;
  border-radius: 0.25rem;
  border: 0.0625rem solid #555;
  background: #1f1f1f;
  color: #f5f5f5;
}

#unlimitedRow {
  display: flex;
  align-items: center;
  gap: 0.375rem;
  justify-content: center;
  margin-top: 0.5rem;
}

.filesRow {
  display: flex;
  justify-content: space-between;
  width: calc(var(--sq) * 8);
  font-size: calc(var(--sq) * 0.22);
  padding: 0 0.25rem;
  box-sizing: border-box;
  opacity: 0.85;
}

.filesRow span {
  width: var(--sq);
  text-align: center;
}

.ranksWrapper {
  display: flex;
  align-items: stretch;
}

.ranksCol {
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  font-size: calc(var(--sq) * 0.22);
  padding: 0.25rem 0.125rem;
  box-sizing: border-box;
  opacity: 0.85;
}

.ranksCol span {
  height: var(--sq);
  display: flex;
  align-items: center;
  justify-content: center;
  width: 0.875rem;
}

#board {
  display: grid;
  grid-template-columns: repeat(8, var(--sq));
  grid-template-rows: repeat(8, var(--sq));
  border: 0.1875rem solid #111;
  border-radius: 0.5rem;
  overflow: hidden;
}

.square {
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: calc(var(--sq) * 0.62);
  cursor: pointer;
  user-select: none;
  box-sizing: border-box;
  touch-action: none;
}

.light-square {
  background: #f0d9b5;
  color: #000;
}

.dark-square {
  background: #b58863;
  color: #000;
}

.square.selected {
  outline: 0.1875rem solid #00bfff;
  outline-offset: -0.1875rem;
}

.square.highlight-move {
  box-shadow: inset 0 0 0 0.25rem rgba(0, 0, 0, 0.3);
}

.square.highlight-capture {
  box-shadow: inset 0 0 0 0.25rem rgba(200, 0, 0, 0.8);
}

.square.last-opponent-from {
  box-shadow: inset 0 0 0 0.25rem rgba(255, 215, 0, 0.95);
}

.square.last-opponent-to {
  box-shadow: inset 0 0 0 0.25rem rgba(50, 205, 50, 0.95);
}

.square.white-piece {
  color: #fff;
  text-shadow:
    0 0 0.0625rem #000,
    0 0 0.125rem #000,
    0 0 0.1875rem #000;
}

.square.black-piece {
  color: #000;
  text-shadow: 0 0 0.0625rem #fff;
}

.drag-ghost {
  position: fixed;
  pointer-events: none;
  font-size: 2.625rem;
  opacity: 0.6;
  transform: translate(-50%, -50%);
  z-index: 9999;
}

.drag-ghost.white {
  color: #ffffff;
  text-shadow: 0 0 0.25rem #000;
}

.drag-ghost.black {
  color: #000000;
  text-shadow: 0 0 0.25rem #fff;
}

#promoChoices {
  display: flex;
  justify-content: center;
  gap: 0.875rem;
  flex-wrap: nowrap;
}

#gameOverModalMessage {
  margin-bottom: 0.625rem;
  font-size: 0.875rem;
  line-height: 1.3;
}

#gameOverRestartBtn {
  padding: 0.625rem 1rem;
  font-size: 0.875rem;
  border-radius: 0.5rem;
  border: none;
  cursor: pointer;
  background: #4caf50;
  color: #fff;
  font-weight: 700;
  width: 100%;
}

#gameOverRestartBtn:hover {
  opacity: 0.92;
}
  </style>
</head>

<body>
  <div class="container">
    <h1>Rakibiniz: Rastgele Hamle Yapan Bilgisayar</h1>
    <div id="status">Önce taş renginizi ve süreyi seçin.</div>
    <div id="clocks">
      <div id="blackClockLabel">Siyah: <span id="blackClock">05:00</span></div>
      <div id="whiteClockLabel">Beyaz: <span id="whiteClock">05:00</span></div>
    </div>
    <div id="filesTop" class="filesRow"></div>
    <div class="ranksWrapper">
      <div id="ranksLeft" class="ranksCol"></div>
      <div id="board"></div>
      <div id="ranksRight" class="ranksCol"></div>
    </div>
    <div id="filesBottom" class="filesRow"></div>

    <div id="sideOverlay" class="overlay">
      <div id="sideSelect" class="modal">
        <div id="sideSelectTitle">Taş renginizi seçin:</div>
        <div id="sideIcons">
          <button id="playBlack" class="sideBlack" title="Siyahla oyna">♚</button>
          <button id="playWhite" class="sideWhite" title="Beyazla oyna">♔</button>
        </div>

        <div id="timeSettings">
          <div><strong>Süre:</strong> Dakika + hamle başı eklenen Saniye</div>

          <label id="unlimitedRow">
            <input type="checkbox" id="unlimitedTime">
            <span>Sınırsız süre</span>
          </label>

          <div id="timeInputsWrap">

            <div id="timeSettingsRow">
              <label>
                Dakika:
                <input type="number" id="timeMinutes" min="0" step="1" inputmode="decimal" autocomplete="off" value="5"
                  placeholder="örn. 0.25">
              </label>
              <label>
                Ek saniye:
                <input type="number" id="timeIncrement" min="0" step="1" value="3">
              </label>
            </div>

          </div>
        </div>
      </div>
    </div>

    <div id="promoOverlay" class="overlay" style="display:none;">
      <div id="promo" class="modal">
        <div id="promoLabel">Terfi taşını seç:</div>
        <div id="promoChoices"></div>
      </div>
    </div>

    <div id="gameOverOverlay" class="overlay" style="display:none;">
      <div class="modal">
        <div id="gameOverModalMessage"></div>
        <button id="gameOverRestartBtn">Yeniden Başla</button>
      </div>
    </div>

  </div>

  <script>
    let board;
    let whiteToMove;
    let gameOver;
    let selectedSquare = null;
    let legalMovesForSelected = [];

    const DRAG_THRESHOLD_PX = 8;
    let pointerDownInfo = null;
    let suppressClickUntil = 0;

    let dragGhost = null;
    let ghostPiece = null;

    function createGhost(piece, x, y) {
      removeGhost();
      ghostPiece = piece;
      dragGhost = document.createElement('div');
      dragGhost.className = 'drag-ghost ' + (isWhitePiece(piece) ? 'white' : 'black');
      dragGhost.textContent = pieceSymbols[piece] || '';
      document.body.appendChild(dragGhost);
      moveGhost(x, y);
    }

    function moveGhost(x, y) {
      if (!dragGhost) return;
      dragGhost.style.left = x + 'px';
      dragGhost.style.top = y + 'px';
    }

    function removeGhost() {
      if (dragGhost) {
        dragGhost.remove();
        dragGhost = null;
        ghostPiece = null;
      }
    }

    let isDragging = false;

    let castlingRights;
    let enPassantTarget;
    let halfmoveClock;
    let fullmoveNumber;
    let positionCounts;

    let humanIsWhite = true;
    let sideChosen = false;
    let renderFlipped = false;

    let awaitingPromotion = false;
    let pendingPromotionMoves = [];

    let lastOpponentMove = null;

    let baseMinutes = 5;
    let incrementSeconds = 3;
    let unlimitedTimeMode = false;
    let unlimitedGameMode = false;
    let whiteTimeMs = baseMinutes * 60 * 1000;
    let blackTimeMs = baseMinutes * 60 * 1000;
    let clockInterval = null;
    let lastTickTimestamp = null;

    const boardElement = document.getElementById('board');
    const statusElement = document.getElementById('status');

    const sideOverlay = document.getElementById('sideOverlay');
    const playWhiteBtn = document.getElementById('playWhite');
    const playBlackBtn = document.getElementById('playBlack');

    const promoOverlay = document.getElementById('promoOverlay');
    const promoChoices = document.getElementById('promoChoices');

    const gameOverOverlay = document.getElementById('gameOverOverlay');
    const gameOverModalMessage = document.getElementById('gameOverModalMessage');
    const gameOverRestartBtn = document.getElementById('gameOverRestartBtn');

    const filesTopEl = document.getElementById('filesTop');
    const filesBottomEl = document.getElementById('filesBottom');
    const ranksLeftEl = document.getElementById('ranksLeft');
    const ranksRightEl = document.getElementById('ranksRight');

    const whiteClockEl = document.getElementById('whiteClock');
    const blackClockEl = document.getElementById('blackClock');
    const timeMinutesInput = document.getElementById('timeMinutes');
    const timeIncrementInput = document.getElementById('timeIncrement');
    const unlimitedTimeCheckbox = document.getElementById('unlimitedTime');
    const timeInputsWrap = document.getElementById('timeInputsWrap');

    function updateResponsiveSizing() {
      const container = document.querySelector('.container');
      const h1El = document.querySelector('h1');
      if (!container || !boardElement || !h1El) return;

      const cs = getComputedStyle(container);
      const padX = parseFloat(cs.paddingLeft) + parseFloat(cs.paddingRight);
      const padY = parseFloat(cs.paddingTop) + parseFloat(cs.paddingBottom);


      const statusH = statusElement ? statusElement.offsetHeight : 0;
      const clocksH = document.getElementById('clocks') ? document.getElementById('clocks').offsetHeight : 0;

  
      const filesTopH = filesTopEl ? filesTopEl.offsetHeight : 0;
      const filesBottomH = filesBottomEl ? filesBottomEl.offsetHeight : 0;

      const vw = window.innerWidth;
      const vh = window.innerHeight;

      const ranksLeftW = ranksLeftEl ? ranksLeftEl.offsetWidth : 0;
      const ranksRightW = ranksRightEl ? ranksRightEl.offsetWidth : 0;

      const safety = 32;

      const availableH = vh - (h1El.offsetHeight + statusH + clocksH + filesTopH + filesBottomH + padY + safety);
      const availableW = vw - (padX + ranksLeftW + ranksRightW);

      const sqByH = availableH / 8;
      const sqByW = availableW / 8;

      const sq = Math.floor(Math.max(24, Math.min(sqByH, sqByW)));

            const rootFontPx = parseFloat(getComputedStyle(document.documentElement).fontSize) || 16;
      const sqRem = sq / rootFontPx;
      document.documentElement.style.setProperty('--sq', sqRem + 'rem');
}

    const pieceSymbols = {
      'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙',
      'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟︎'
    };

    function isWhitePiece(piece) { return piece && piece === piece.toUpperCase(); }
    function isBlackPiece(piece) { return piece && piece === piece.toLowerCase(); }
    function inBounds(r, c) { return r >= 0 && r < 8 && c >= 0 && c < 8; }
    function cloneBoard(b) { return b.map(row => row.slice()); }

    function makeMoveOnBoard(b, move) {
      const newBoard = cloneBoard(b);
      const piece = newBoard[move.fromRow][move.fromCol];
      newBoard[move.fromRow][move.fromCol] = '';

      if (move.isEnPassant) {
        const capRow = move.fromRow;
        const capCol = move.toCol;
        newBoard[capRow][capCol] = '';
      }

      let newPiece = piece;
      if (move.promotion) newPiece = move.promotion;
      newBoard[move.toRow][move.toCol] = newPiece;

      if (move.isCastling) {
        if (piece === 'K' && move.toCol === 6) {
          newBoard[7][5] = 'R';
          newBoard[7][7] = '';
        } else if (piece === 'K' && move.toCol === 2) {
          newBoard[7][3] = 'R';
          newBoard[7][0] = '';
        } else if (piece === 'k' && move.toCol === 6) {
          newBoard[0][5] = 'r';
          newBoard[0][7] = '';
        } else if (piece === 'k' && move.toCol === 2) {
          newBoard[0][3] = 'r';
          newBoard[0][0] = '';
        }
      }

      return newBoard;
    }

    function findKingPosition(b, isWhite) {
      const target = isWhite ? 'K' : 'k';
      for (let r = 0; r < 8; r++)
        for (let c = 0; c < 8; c++)
          if (b[r][c] === target) return { row: r, col: c };
      return null;
    }

    function pieceAttacksSquare(b, fromRow, fromCol, toRow, toCol) {
      const piece = b[fromRow][fromCol];
      if (!piece) return false;
      const isWhite = isWhitePiece(piece);
      const p = piece.toLowerCase();
      const dr = toRow - fromRow;
      const dc = toCol - fromCol;
      const absDr = Math.abs(dr);
      const absDc = Math.abs(dc);

      if (p === 'p') {
        if (isWhite) return dr === -1 && Math.abs(dc) === 1;
        return dr === 1 && Math.abs(dc) === 1;
      }

      if (p === 'n') {
        return (absDr === 2 && absDc === 1) || (absDr === 1 && absDc === 2);
      }

      if (p === 'b') {
        if (absDr !== absDc || absDr === 0) return false;
        const stepR = dr > 0 ? 1 : -1;
        const stepC = dc > 0 ? 1 : -1;
        for (let i = 1; i < absDr; i++) {
          if (b[fromRow + i * stepR][fromCol + i * stepC] !== '') return false;
        }
        return true;
      }

      if (p === 'r') {
        if (!(fromRow === toRow || fromCol === toCol)) return false;
        if (fromRow === toRow) {
          const stepC = dc > 0 ? 1 : -1;
          for (let c = fromCol + stepC; c !== toCol; c += stepC)
            if (b[fromRow][c] !== '') return false;
        } else {
          const stepR = dr > 0 ? 1 : -1;
          for (let r = fromRow + stepR; r !== toRow; r += stepR)
            if (b[r][fromCol] !== '') return false;
        }
        return true;
      }

      if (p === 'q') {
        if (absDr === absDc && absDr !== 0) {
          const stepR = dr > 0 ? 1 : -1;
          const stepC = dc > 0 ? 1 : -1;
          for (let i = 1; i < absDr; i++) {
            if (b[fromRow + i * stepR][fromCol + i * stepC] !== '') return false;
          }
          return true;
        } else if (fromRow === toRow || fromCol === toCol) {
          if (fromRow === toRow) {
            const stepC = dc > 0 ? 1 : -1;
            for (let c = fromCol + stepC; c !== toCol; c += stepC)
              if (b[fromRow][c] !== '') return false;
          } else {
            const stepR = dr > 0 ? 1 : -1;
            for (let r = fromRow + stepR; r !== toRow; r += stepR)
              if (b[r][fromCol] !== '') return false;
          }
          return true;
        }
        return false;
      }

      if (p === 'k') {
        return absDr <= 1 && absDc <= 1 && (absDr + absDc > 0);
      }

      return false;
    }

    function isSquareAttacked(b, row, col, byWhite) {
      for (let r = 0; r < 8; r++)
        for (let c = 0; c < 8; c++) {
          const piece = b[r][c];
          if (!piece) continue;
          if (byWhite && !isWhitePiece(piece)) continue;
          if (!byWhite && !isBlackPiece(piece)) continue;
          if (pieceAttacksSquare(b, r, c, row, col)) return true;
        }
      return false;
    }

    function isInCheck(b, isWhite) {
      const kingPos = findKingPosition(b, isWhite);
      if (!kingPos) return false;
      return isSquareAttacked(b, kingPos.row, kingPos.col, !isWhite);
    }

    function generatePseudoMovesForPiece(b, row, col, isWhiteTurn) {
      const moves = [];
      const piece = b[row][col];
      if (!piece) return moves;
      const isWhite = isWhitePiece(piece);
      if (isWhite !== isWhiteTurn) return moves;
      const p = piece.toLowerCase();

      const pushMove = (toRow, toCol, options = {}) => {
        if (!inBounds(toRow, toCol)) return;
        const target = b[toRow][toCol];
        if (!options.isEnPassant) {
          if (target && ((isWhite && isWhitePiece(target)) || (!isWhite && isBlackPiece(target)))) return;
        }
        moves.push({
          fromRow: row,
          fromCol: col,
          toRow,
          toCol,
          promotion: options.promotion || null,
          isEnPassant: !!options.isEnPassant,
          isCastling: !!options.isCastling
        });
      };

      if (p === 'p') {
        const dir = isWhite ? -1 : 1;
        const startRow = isWhite ? 6 : 1;
        const lastRank = isWhite ? 0 : 7;

        const oneStepRow = row + dir;
        if (inBounds(oneStepRow, col) && b[oneStepRow][col] === '') {
          if (oneStepRow === lastRank) {
            const promos = isWhite ? ['Q', 'R', 'B', 'N'] : ['q', 'r', 'b', 'n'];
            promos.forEach(pp => pushMove(oneStepRow, col, { promotion: pp }));
          } else {
            pushMove(oneStepRow, col);
          }

          const twoStepRow = row + 2 * dir;
          if (row === startRow && inBounds(twoStepRow, col) && b[twoStepRow][col] === '') {
            pushMove(twoStepRow, col);
          }
        }

        for (let dc of [-1, 1]) {
          const tr = row + dir;
          const tc = col + dc;
          if (!inBounds(tr, tc)) continue;
          const target = b[tr][tc];
          if (target && ((isWhite && isBlackPiece(target)) || (!isWhite && isWhitePiece(target)))) {
            if (tr === lastRank) {
              const promos = isWhite ? ['Q', 'R', 'B', 'N'] : ['q', 'r', 'b', 'n'];
              promos.forEach(pp => pushMove(tr, tc, { promotion: pp }));
            } else {
              pushMove(tr, tc);
            }
          }
        }

        if (enPassantTarget) {
          for (let dc of [-1, 1]) {
            const tr = row + dir;
            const tc = col + dc;
            if (tr === enPassantTarget.row && tc === enPassantTarget.col) {
              const capRow = row;
              const capCol = tc;
              const targetPawn = b[capRow][capCol];
              if (targetPawn && ((isWhite && isBlackPiece(targetPawn)) || (!isWhite && isWhitePiece(targetPawn)))) {
                pushMove(tr, tc, { isEnPassant: true });
              }
            }
          }
        }

        return moves;
      }

      if (p === 'n') {
        const knightMoves = [
          [2, 1], [2, -1], [-2, 1], [-2, -1],
          [1, 2], [1, -2], [-1, 2], [-1, -2]
        ];
        for (let [dr, dc] of knightMoves) {
          const tr = row + dr;
          const tc = col + dc;
          if (!inBounds(tr, tc)) continue;
          const target = b[tr][tc];
          if (!target || (isWhite && isBlackPiece(target)) || (!isWhite && isWhitePiece(target))) {
            pushMove(tr, tc);
          }
        }
        return moves;
      }

      if (p === 'b' || p === 'q') {
        const directions = [
          [1, 1], [1, -1], [-1, 1], [-1, -1]
        ];
        for (let [dr, dc] of directions) {
          let tr = row + dr;
          let tc = col + dc;
          while (inBounds(tr, tc)) {
            const target = b[tr][tc];
            if (!target) {
              pushMove(tr, tc);
            } else {
              if ((isWhite && isBlackPiece(target)) || (!isWhite && isWhitePiece(target))) {
                pushMove(tr, tc);
              }
              break;
            }
            tr += dr;
            tc += dc;
          }
        }
      }

      if (p === 'r' || p === 'q') {
        const directions = [
          [1, 0], [-1, 0], [0, 1], [0, -1]
        ];
        for (let [dr, dc] of directions) {
          let tr = row + dr;
          let tc = col + dc;
          while (inBounds(tr, tc)) {
            const target = b[tr][tc];
            if (!target) {
              pushMove(tr, tc);
            } else {
              if ((isWhite && isBlackPiece(target)) || (!isWhite && isWhitePiece(target))) {
                pushMove(tr, tc);
              }
              break;
            }
            tr += dr;
            tc += dc;
          }
        }
      }

      if (p === 'k') {
        for (let dr = -1; dr <= 1; dr++)
          for (let dc = -1; dc <= 1; dc++) {
            if (dr === 0 && dc === 0) continue;
            const tr = row + dr;
            const tc = col + dc;
            if (!inBounds(tr, tc)) continue;
            const target = b[tr][tc];
            if (!target || (isWhite && isBlackPiece(target)) || (!isWhite && isWhitePiece(target))) {
              pushMove(tr, tc);
            }
          }

        const isWhiteSide = isWhite;
        const rank = isWhiteSide ? 7 : 0;
        const kingFile = 4;
        if (row === rank && col === kingFile && !isInCheck(b, isWhiteSide)) {
          const rights = castlingRights;
          const byWhite = !isWhiteSide;

          if ((isWhiteSide && rights.whiteK) || (!isWhiteSide && rights.blackK)) {
            if (b[rank][5] === '' && b[rank][6] === '' &&
              b[rank][7] === (isWhiteSide ? 'R' : 'r') &&
              !isSquareAttacked(b, rank, 5, byWhite) &&
              !isSquareAttacked(b, rank, 6, byWhite)) {
              pushMove(rank, 6, { isCastling: true });
            }
          }

          if ((isWhiteSide && rights.whiteQ) || (!isWhiteSide && rights.blackQ)) {
            if (b[rank][1] === '' && b[rank][2] === '' && b[rank][3] === '' &&
              b[rank][0] === (isWhiteSide ? 'R' : 'r') &&
              !isSquareAttacked(b, rank, 3, byWhite) &&
              !isSquareAttacked(b, rank, 2, byWhite)) {
              pushMove(rank, 2, { isCastling: true });
            }
          }
        }
      }

      return moves;
    }

    function generateLegalMoves(isWhiteTurn) {
      const result = [];
      for (let r = 0; r < 8; r++)
        for (let c = 0; c < 8; c++) {
          const piece = board[r][c];
          if (!piece) continue;
          if (isWhiteTurn && !isWhitePiece(piece)) continue;
          if (!isWhiteTurn && !isBlackPiece(piece)) continue;
          const pseudoMoves = generatePseudoMovesForPiece(board, r, c, isWhiteTurn);
          for (let m of pseudoMoves) {
            const newBoard = makeMoveOnBoard(board, m);
            if (!isInCheck(newBoard, isWhiteTurn)) result.push(m);
          }
        }
      return result;
    }

    function getCastlingRightsString() {
      let s = '';
      if (castlingRights.whiteK) s += 'K';
      if (castlingRights.whiteQ) s += 'Q';
      if (castlingRights.blackK) s += 'k';
      if (castlingRights.blackQ) s += 'q';
      return s || '-';
    }

    function getEnPassantString() {
      if (!enPassantTarget) return '-';
      const files = 'abcdefgh';
      const ranks = '87654321';
      const file = files[enPassantTarget.col];
      const rank = ranks[enPassantTarget.row];
      return file + rank;
    }

    function getPositionKey() {
      const rows = board.map(row => row.map(p => p || '.').join('')).join('/');
      const side = whiteToMove ? 'w' : 'b';
      const castles = getCastlingRightsString();
      const ep = getEnPassantString();
      return rows + ' ' + side + ' ' + castles + ' ' + ep;
    }

    function recordPosition() {
      const key = getPositionKey();
      positionCounts[key] = (positionCounts[key] || 0) + 1;
    }

    function isThreefoldRepetition() {
      const key = getPositionKey();
      return (positionCounts[key] || 0) >= 3;
    }

    function hasSufficientMaterial(b) {
      let whiteBishops = [];
      let blackBishops = [];
      let whiteKnights = 0;
      let blackKnights = 0;

      for (let r = 0; r < 8; r++)
        for (let c = 0; c < 8; c++) {
          const piece = b[r][c];
          if (!piece) continue;
          const p = piece.toLowerCase();
          if (p === 'k') continue;

          if (p === 'p' || p === 'q' || p === 'r') {
            return true;
          }

          const isWhite = isWhitePiece(piece);
          if (p === 'b') {
            const isLightSquare = (r + c) % 2 === 0;
            if (isWhite) whiteBishops.push(isLightSquare);
            else blackBishops.push(isLightSquare);
          } else if (p === 'n') {
            if (isWhite) whiteKnights++;
            else blackKnights++;
          }
        }

      const totalMinors = whiteBishops.length + blackBishops.length + whiteKnights + blackKnights;

      if (totalMinors === 0) return false;
      if (totalMinors === 1) return false;

      if (totalMinors === 2 &&
        whiteKnights === 0 && blackKnights === 0 &&
        whiteBishops.length + blackBishops.length === 2) {
        const allBishops = whiteBishops.concat(blackBishops);
        const allSameColor = allBishops.every(v => v === allBishops[0]);
        if (allSameColor) return false;
      }

      return true;
    }

    function sideHasMatingMaterial(b, isWhiteSide) {
      let hasPawnOrBig = false;
      let bishops = 0;
      let knights = 0;

      for (let r = 0; r < 8; r++)
        for (let c = 0; c < 8; c++) {
          const piece = b[r][c];
          if (!piece) continue;
          const isWhite = isWhitePiece(piece);
          if (isWhite !== isWhiteSide) continue;

          const p = piece.toLowerCase();
          if (p === 'p' || p === 'q' || p === 'r') {
            hasPawnOrBig = true;
          } else if (p === 'b') {
            bishops++;
          } else if (p === 'n') {
            knights++;
          }
        }

      if (hasPawnOrBig) return true;
      if (bishops + knights >= 2) return true;
      return false;
    }

    function evaluateGameStateAfterMove() {
      if (halfmoveClock >= 100) {
        return { gameOver: true, message: "Berabere: 50 hamle kuralı." };
      }

      if (!hasSufficientMaterial(board)) {
        return { gameOver: true, message: "Berabere: yetersiz materyal." };
      }

      if (isThreefoldRepetition()) {
        return { gameOver: true, message: "Berabere: aynı pozisyon 3 kez tekrarlandı." };
      }

      const sideToMoveIsWhite = whiteToMove;
      const legal = generateLegalMoves(sideToMoveIsWhite);
      if (legal.length === 0) {
        if (isInCheck(board, sideToMoveIsWhite)) {
          if (sideToMoveIsWhite) {
            return { gameOver: true, message: "Mat! Siyah kazandı." };
          } else {
            return { gameOver: true, message: "Mat! Beyaz kazandı." };
          }
        } else {
          return { gameOver: true, message: "Berabere: pat." };
        }
      }

      return { gameOver: false, message: null };
    }

    function applyMove(move) {
      const fromRow = move.fromRow;
      const fromCol = move.fromCol;
      const toRow = move.toRow;
      const toCol = move.toCol;

      const piece = board[fromRow][fromCol];
      const targetBefore = board[toRow][toCol];

      let capturedPiece = targetBefore;
      if (move.isEnPassant) {
        const capRow = fromRow;
        const capCol = toCol;
        capturedPiece = board[capRow][capCol];
      }

      if (piece.toLowerCase() === 'p' || capturedPiece) {
        halfmoveClock = 0;
      } else {
        halfmoveClock++;
      }

      enPassantTarget = null;

      if (move.isEnPassant) {
        board[fromRow][fromCol] = '';
        const capRow = fromRow;
        const capCol = toCol;
        board[capRow][capCol] = '';
        const newPiece = move.promotion ? move.promotion : piece;
        board[toRow][toCol] = newPiece;
      } else if (move.isCastling) {
        board[fromRow][fromCol] = '';
        board[toRow][toCol] = piece;
        if (piece === 'K') {
          if (toCol === 6) {
            board[7][7] = '';
            board[7][5] = 'R';
          } else if (toCol === 2) {
            board[7][0] = '';
            board[7][3] = 'R';
          }
        } else if (piece === 'k') {
          if (toCol === 6) {
            board[0][7] = '';
            board[0][5] = 'r';
          } else if (toCol === 2) {
            board[0][0] = '';
            board[0][3] = 'r';
          }
        }
      } else {
        board[fromRow][fromCol] = '';
        const newPiece = move.promotion ? move.promotion : piece;
        board[toRow][toCol] = newPiece;

        if (piece.toLowerCase() === 'p' && Math.abs(toRow - fromRow) === 2) {
          const midRow = (toRow + fromRow) / 2;
          enPassantTarget = { row: midRow, col: fromCol };
        }
      }

      if (piece === 'K') {
        castlingRights.whiteK = false;
        castlingRights.whiteQ = false;
      } else if (piece === 'k') {
        castlingRights.blackK = false;
        castlingRights.blackQ = false;
      }

      if (piece === 'R') {
        if (fromRow === 7 && fromCol === 0) castlingRights.whiteQ = false;
        if (fromRow === 7 && fromCol === 7) castlingRights.whiteK = false;
      } else if (piece === 'r') {
        if (fromRow === 0 && fromCol === 0) castlingRights.blackQ = false;
        if (fromRow === 0 && fromCol === 7) castlingRights.blackK = false;
      }

      if (capturedPiece === 'R') {
        if (toRow === 7 && toCol === 0) castlingRights.whiteQ = false;
        if (toRow === 7 && toCol === 7) castlingRights.whiteK = false;
      } else if (capturedPiece === 'r') {
        if (toRow === 0 && toCol === 0) castlingRights.blackQ = false;
        if (toRow === 0 && toCol === 7) castlingRights.blackK = false;
      }

      whiteToMove = !whiteToMove;
      if (whiteToMove) fullmoveNumber++;

      recordPosition();
    }

    function renderCoords() {
      const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];

      filesTopEl.innerHTML = '';
      filesBottomEl.innerHTML = '';
      ranksLeftEl.innerHTML = '';
      ranksRightEl.innerHTML = '';

      const filesLR = renderFlipped ? [...files].reverse() : files;
      const ranksTB = renderFlipped ? [1, 2, 3, 4, 5, 6, 7, 8] : [8, 7, 6, 5, 4, 3, 2, 1];

      filesLR.forEach(ch => {
        const sp = document.createElement('span');
        sp.textContent = ch;
        filesTopEl.appendChild(sp);
      });
      filesLR.forEach(ch => {
        const sp = document.createElement('span');
        sp.textContent = ch;
        filesBottomEl.appendChild(sp);
      });

      ranksTB.forEach(r => {
        const sp = document.createElement('span');
        sp.textContent = r;
        ranksLeftEl.appendChild(sp);
      });
      ranksTB.forEach(r => {
        const sp = document.createElement('span');
        sp.textContent = r;
        ranksRightEl.appendChild(sp);
      });
    }

    function renderBoard() {
      boardElement.innerHTML = '';
      for (let vr = 0; vr < 8; vr++) {
        for (let vc = 0; vc < 8; vc++) {
          const r = renderFlipped ? 7 - vr : vr;
          const c = renderFlipped ? 7 - vc : vc;

          const square = document.createElement('div');
          square.classList.add('square');
          const isLight = (r + c) % 2 === 0;
          square.classList.add(isLight ? 'light-square' : 'dark-square');
          square.dataset.row = r;
          square.dataset.col = c;

          const piece = board[r][c];
          if (piece) {
            square.textContent = pieceSymbols[piece] || '';
            if (isWhitePiece(piece)) {
              square.classList.add('white-piece');
            } else {
              square.classList.add('black-piece');
            }
          }

          if (selectedSquare && selectedSquare.row === r && selectedSquare.col === c) {
            square.classList.add('selected');
          }

          const highlight = legalMovesForSelected.find(m => m.toRow === r && m.toCol === c);
          if (highlight) {
            const target = board[r][c];
            if (target && ((whiteToMove && isBlackPiece(target)) || (!whiteToMove && isWhitePiece(target)))) {
              square.classList.add('highlight-capture');
            } else {
              square.classList.add('highlight-move');
            }
          }

          if (lastOpponentMove) {
            if (lastOpponentMove.fromRow === r && lastOpponentMove.fromCol === c) {
              square.classList.add('last-opponent-from');
            }
            if (lastOpponentMove.toRow === r && lastOpponentMove.toCol === c) {
              square.classList.add('last-opponent-to');
            }
          }

          square.addEventListener('click', onSquareClick);
          square.addEventListener('pointerdown', onSquarePointerDown);
          square.addEventListener('pointermove', onSquarePointerMove);
          square.addEventListener('pointerup', onSquarePointerUp);
          square.addEventListener('pointercancel', onSquarePointerCancel);
          boardElement.appendChild(square);
        }
      }
    }

    function showPromotionChoices(moves) {
      awaitingPromotion = true;
      pendingPromotionMoves = moves;
      promoChoices.innerHTML = '';

      const unique = [];
      moves.forEach(m => {
        const up = m.promotion.toUpperCase();
        if (!unique.includes(up)) unique.push(up);
      });

      unique.forEach(ch => {
        const btn = document.createElement('button');
        const pieceChar = humanIsWhite ? ch : ch.toLowerCase();
        btn.textContent = pieceSymbols[pieceChar];
        btn.dataset.piece = ch;
        btn.onclick = () => {
          const chosen = btn.dataset.piece;
          const mv = pendingPromotionMoves.find(m => m.promotion.toUpperCase() === chosen);
          awaitingPromotion = false;
          pendingPromotionMoves = [];
          promoOverlay.style.display = 'none';
          if (gameOverOverlay) gameOverOverlay.style.display = 'none';
          if (mv) playerMove(mv);
        };
        promoChoices.appendChild(btn);
      });

      promoOverlay.style.display = 'flex';
    }

    function canHumanInteract() {
      if (gameOver || awaitingPromotion || !sideChosen) return false;
      if (whiteToMove !== humanIsWhite) return false;
      return true;
    }

    function isHumanPieceAt(row, col) {
      const piece = board[row][col];
      if (!piece) return false;
      return (humanIsWhite && isWhitePiece(piece)) || (!humanIsWhite && isBlackPiece(piece));
    }

    function computeAndShowMovesForSquare(row, col) {
      selectedSquare = { row, col };
      const allLegal = generateLegalMoves(whiteToMove);
      legalMovesForSelected = allLegal.filter(m => m.fromRow === row && m.fromCol === col);
      renderBoard();
    }

    function onSquarePointerDown(e) {
      if (!canHumanInteract()) return;

      const row = parseInt(e.currentTarget.dataset.row, 10);
      const col = parseInt(e.currentTarget.dataset.col, 10);

      if (!isHumanPieceAt(row, col)) return;

      pointerDownInfo = { row, col, startX: e.clientX, startY: e.clientY, pointerId: e.pointerId };
      isDragging = false;

      try { e.currentTarget.setPointerCapture(e.pointerId); } catch (_) { }
    }

    function onSquarePointerMove(e) {
      if (!pointerDownInfo) return;
      if (!canHumanInteract()) return;

      const dx = e.clientX - pointerDownInfo.startX;
      const dy = e.clientY - pointerDownInfo.startY;
      const dist = Math.hypot(dx, dy);

      if (!isDragging && dist >= DRAG_THRESHOLD_PX) {
        isDragging = true;
        computeAndShowMovesForSquare(pointerDownInfo.row, pointerDownInfo.col);

        const piece = board[pointerDownInfo.row][pointerDownInfo.col];
        if (piece) createGhost(piece, e.clientX, e.clientY);
      }

      if (isDragging) {
        moveGhost(e.clientX, e.clientY);
      }
    }

    function finalizeDragOrClick(e) {
      if (!pointerDownInfo) return;
      if (!canHumanInteract()) {
        pointerDownInfo = null;
        isDragging = false;
        return;
      }

      const fromRow = pointerDownInfo.row;
      const fromCol = pointerDownInfo.col;

      // TAP: let the normal click handler process selection/move.
      if (!isDragging) {
        pointerDownInfo = null;
        isDragging = false;
        return;
      }

      // DRAG: complete the drag move, then suppress the synthetic click some mobiles fire after pointerup.
      suppressClickUntil = Date.now() + 250;
      e.preventDefault();
      e.stopPropagation();

      removeGhost();
      const el = document.elementFromPoint(e.clientX, e.clientY);
      const sq = el && el.closest ? el.closest('.square') : null;

      pointerDownInfo = null;
      isDragging = false;

      if (!sq || !sq.dataset) {
        renderBoard();
        return;
      }

      const toRow = parseInt(sq.dataset.row, 10);
      const toCol = parseInt(sq.dataset.col, 10);

      const candidates = legalMovesForSelected.filter(m =>
        m.fromRow === fromRow && m.fromCol === fromCol &&
        m.toRow === toRow && m.toCol === toCol
      );

      if (candidates.length === 0) {
        renderBoard();
        return;
      }

      const promoMoves = candidates.filter(m => m.promotion);
      if (promoMoves.length > 0) {
        showPromotionChoices(promoMoves);
      } else {
        playerMove(candidates[0]);
        selectedSquare = null;
        legalMovesForSelected = [];
      }

      renderBoard();
    }

    function onSquarePointerUp(e) { finalizeDragOrClick(e); }
    function onSquarePointerCancel(e) {
      pointerDownInfo = null;
      isDragging = false;
      renderBoard();

      removeGhost();
    }

    function onSquareClick(e) {
      if (Date.now() < suppressClickUntil) return;
      if (gameOver || awaitingPromotion || !sideChosen) return;
      if (whiteToMove !== humanIsWhite) return;

      const row = parseInt(e.currentTarget.dataset.row, 10);
      const col = parseInt(e.currentTarget.dataset.col, 10);
      const clickedPiece = board[row][col];

      const isHumanPiece = clickedPiece &&
        ((humanIsWhite && isWhitePiece(clickedPiece)) || (!humanIsWhite && isBlackPiece(clickedPiece)));

      if (!selectedSquare) {
        if (isHumanPiece) {
          selectedSquare = { row, col };
          const allLegal = generateLegalMoves(whiteToMove);
          legalMovesForSelected = allLegal.filter(
            m => m.fromRow === row && m.fromCol === col
          );
        }
      } else {
        if (selectedSquare.row === row && selectedSquare.col === col) {
          selectedSquare = null;
          legalMovesForSelected = [];
        } else {
          const candidateMoves = legalMovesForSelected.filter(
            m => m.toRow === row && m.toCol === col
          );

          if (candidateMoves.length > 0) {
            const promoMoves = candidateMoves.filter(m => m.promotion);
            if (promoMoves.length > 0) {
              showPromotionChoices(promoMoves);
            } else {
              playerMove(candidateMoves[0]);
            }
          } else {
            if (isHumanPiece) {
              selectedSquare = { row, col };
              const allLegal = generateLegalMoves(whiteToMove);
              legalMovesForSelected = allLegal.filter(
                m => m.fromRow === row && m.fromCol === col
              );
            }
          }
        }
      }
      renderBoard();
    }

    function formatTime(ms) {
      const totalSec = Math.max(0, Math.floor(ms / 1000));
      const m = Math.floor(totalSec / 60);
      const s = totalSec % 60;
      return String(m).padStart(2, '0') + ":" + String(s).padStart(2, '0');
    }

    function roundTo2(v) {
      return Math.round(v * 100) / 100;
    }

    function parseMinutesInputValue(raw) {
      const str = String(raw ?? '').trim().replace(',', '.');
      let v = parseFloat(str);
      if (!Number.isFinite(v)) return null;
      v = roundTo2(v);
      if (v < 0) v = 0;
      return v;
    }

    function syncTimeSettingsUI() {
      unlimitedTimeMode = !!(unlimitedTimeCheckbox && unlimitedTimeCheckbox.checked);
      if (timeInputsWrap) {
        timeInputsWrap.style.display = unlimitedTimeMode ? 'none' : 'block';
      }

      const minutesParsed = timeMinutesInput ? parseMinutesInputValue(timeMinutesInput.value) : null;
      const m = (minutesParsed === null) ? 5 : minutesParsed;
      const sRaw = timeIncrementInput ? parseInt(timeIncrementInput.value, 10) : 0;
      const s = (Number.isFinite(sRaw) && sRaw >= 0) ? sRaw : 0;

      unlimitedGameMode = unlimitedTimeMode || (m === 0 && s === 0);

      updateClocks();
    }

    function readTimeSettingsFromInputs() {
      syncTimeSettingsUI();

      if (unlimitedTimeMode) {
        unlimitedGameMode = true;
        return { unlimited: true, baseMinutes: 0, incrementSeconds: 0 };
      }

      const minutesParsed = parseMinutesInputValue(timeMinutesInput.value);
      let m = (minutesParsed === null) ? 5 : minutesParsed;

      let s = parseInt(timeIncrementInput.value, 10);
      if (!Number.isFinite(s) || s < 0) s = 0;

      if (m === 0 && s === 0) {
        unlimitedGameMode = true;
        timeMinutesInput.value = String(roundTo2(m));
        return { unlimited: true, baseMinutes: 0, incrementSeconds: 0 };
      }

      unlimitedGameMode = false;

      timeMinutesInput.value = String(roundTo2(m));

      return { unlimited: false, baseMinutes: m, incrementSeconds: s };
    }
    function updateClocks() {
      if (unlimitedGameMode) {
        whiteClockEl.textContent = "∞";
        blackClockEl.textContent = "∞";
        return;
      }
      whiteClockEl.textContent = formatTime(whiteTimeMs);
      blackClockEl.textContent = formatTime(blackTimeMs);
    }

    function stopClock() {
      if (clockInterval !== null) {
        clearInterval(clockInterval);
        clockInterval = null;
      }
      lastTickTimestamp = null;
    }

    function endGame(message) {
      gameOver = true;
      stopClock();
      statusElement.textContent = message;

      if (gameOverModalMessage) gameOverModalMessage.textContent = message;
      if (gameOverOverlay) gameOverOverlay.style.display = 'flex';

    }

    function tickClock() {
      if (gameOver || !sideChosen) return;
      if (unlimitedGameMode) return;
      const now = Date.now();
      if (lastTickTimestamp === null) {
        lastTickTimestamp = now;
        return;
      }
      const elapsed = now - lastTickTimestamp;
      lastTickTimestamp = now;

      if (whiteToMove) {
        whiteTimeMs -= elapsed;
        if (whiteTimeMs <= 0) {
          whiteTimeMs = 0;
          updateClocks();
          handleTimeOver(true);
          return;
        }
      } else {
        blackTimeMs -= elapsed;
        if (blackTimeMs <= 0) {
          blackTimeMs = 0;
          updateClocks();
          handleTimeOver(false);
          return;
        }
      }
      updateClocks();
    }

    function startClock() {
      stopClock();
      if (unlimitedGameMode) return;
      lastTickTimestamp = Date.now();
      clockInterval = setInterval(tickClock, 100);
    }


    function handleTimeOver(flagFellIsWhite) {
      if (gameOver) return;

      const winnerIsWhite = !flagFellIsWhite;
      const winnerHasMat = sideHasMatingMaterial(board, winnerIsWhite);

      if (winnerHasMat) {
        if (flagFellIsWhite) {
          endGame("Beyazın süresi bitti. Siyah kazandı.");
        } else {
          endGame("Siyahın süresi bitti. Beyaz kazandı.");
        }
      } else {
        endGame("Süre bitti ama rakibin mat için yeterli taşları yok. Oyun berabere.");
      }
    }

    function playerMove(move) {

      const movingIsWhite = whiteToMove;

      applyMove(move);

      if (movingIsWhite) {
        whiteTimeMs += incrementSeconds * 1000;
      } else {
        blackTimeMs += incrementSeconds * 1000;
      }
      updateClocks();

      selectedSquare = null;
      legalMovesForSelected = [];
      renderBoard();

      const result = evaluateGameStateAfterMove();
      if (result.gameOver) {
        endGame(result.message);
        return;
      }

      const computerIsWhite = !humanIsWhite;
      statusElement.textContent = computerIsWhite ? "Beyaz düşünüyor (rastgele hamle)..." : "Siyah düşünüyor (rastgele hamle)...";
      setTimeout(computerMove, 400);
    }

    function computerMove() {
      if (gameOver || !sideChosen) return;

      const legal = generateLegalMoves(whiteToMove);
      if (legal.length === 0) {
        const result = evaluateGameStateAfterMove();
        endGame(result.message);
        return;
      }

// Zeka parametresi buraya eklenebilir.

      const randomIndex = Math.floor(Math.random() * legal.length);
      const move = legal[randomIndex];

      if (move.promotion) {
        move.promotion = whiteToMove ? 'Q' : 'q';
      }

      const movingIsWhite = whiteToMove;

      applyMove(move);

      if (movingIsWhite) {
        whiteTimeMs += incrementSeconds * 1000;
      } else {
        blackTimeMs += incrementSeconds * 1000;
      }

      lastOpponentMove = {
        fromRow: move.fromRow,
        fromCol: move.fromCol,
        toRow: move.toRow,
        toCol: move.toCol
      };

      updateClocks();
      renderBoard();

      const result = evaluateGameStateAfterMove();
      if (result.gameOver) {
        endGame(result.message);
        return;
      }

      statusElement.textContent = humanIsWhite ? "Sıra sizde (Beyaz)." : "Sıra sizde (Siyah).";
    }

    function resetGame() {
      stopClock();

      board = [
        ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
        ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
        ['', '', '', '', '', '', '', ''],
        ['', '', '', '', '', '', '', ''],
        ['', '', '', '', '', '', '', ''],
        ['', '', '', '', '', '', '', ''],
        ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
        ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
      ];
      whiteToMove = true;
      gameOver = false;
      selectedSquare = null;
      legalMovesForSelected = [];
      castlingRights = { whiteK: true, whiteQ: true, blackK: true, blackQ: true };
      enPassantTarget = null;
      halfmoveClock = 0;
      fullmoveNumber = 1;
      positionCounts = {};
      awaitingPromotion = false;
      pendingPromotionMoves = [];
      sideChosen = false;
      renderFlipped = !humanIsWhite ? true : false;

      lastOpponentMove = null;

      const ts = readTimeSettingsFromInputs();
      baseMinutes = ts.baseMinutes;
      incrementSeconds = ts.incrementSeconds;

      whiteTimeMs = baseMinutes * 60 * 1000;
      blackTimeMs = baseMinutes * 60 * 1000;
      updateClocks();

      sideOverlay.style.display = 'flex';
      promoOverlay.style.display = 'none';
      if (gameOverOverlay) gameOverOverlay.style.display = 'none';
      statusElement.textContent = "Önce taş renginizi ve süreyi seçin.";
      renderCoords();
      renderBoard();
      recordPosition();
    }

    function initTimeFromInputs() {
      const ts = readTimeSettingsFromInputs();
      baseMinutes = ts.baseMinutes;
      incrementSeconds = ts.incrementSeconds;

      whiteTimeMs = baseMinutes * 60 * 1000;
      blackTimeMs = baseMinutes * 60 * 1000;
      updateClocks();
    }

    playWhiteBtn.addEventListener('click', () => {
      humanIsWhite = true;
      renderFlipped = false;
      sideChosen = true;
      initTimeFromInputs();
      sideOverlay.style.display = 'none';
      statusElement.textContent = "Sıra sizde (Beyaz).";

      renderCoords(); renderBoard();
      startClock();
    });

    playBlackBtn.addEventListener('click', () => {
      humanIsWhite = false;
      renderFlipped = true;
      sideChosen = true;
      initTimeFromInputs();
      sideOverlay.style.display = 'none';
      statusElement.textContent = "Beyaz düşünüyor (rastgele hamle)...";

      renderCoords(); renderBoard();
      startClock(); 
      setTimeout(computerMove, 400);
    });

    gameOverRestartBtn.addEventListener('click', resetGame);

    if (unlimitedTimeCheckbox) {
      unlimitedTimeCheckbox.addEventListener('change', () => {
        syncTimeSettingsUI();
      });
    }

    if (timeMinutesInput) {
      timeMinutesInput.addEventListener('blur', () => {
        if (unlimitedTimeMode) return;
        const parsed = parseMinutesInputValue(timeMinutesInput.value);
        const normalized = (parsed === null ? 5 : parsed);
        timeMinutesInput.value = String(roundTo2(normalized));
        syncTimeSettingsUI();
      });
    }

    if (timeIncrementInput) {
      timeIncrementInput.addEventListener('change', () => {
        if (unlimitedTimeMode) return;
        const s = parseInt(timeIncrementInput.value, 10);
        if (!Number.isFinite(s) || s < 0) timeIncrementInput.value = "0";
        syncTimeSettingsUI();
      });
    }

    updateResponsiveSizing();
    window.addEventListener('resize', () => {
      updateResponsiveSizing();
      renderCoords();
      renderBoard();
    });

    requestAnimationFrame(() => {
      updateResponsiveSizing();
      renderCoords();
      renderBoard();
    });

    resetGame();
  </script>
</body>

</html>